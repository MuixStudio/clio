// Code generated by Kitex v0.15.1. DO NOT EDIT.

package user

import (
	"context"
	"errors"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "github.com/cloudwego/prutal"
	userService "github.com/muixstudio/clio/internal/common/pb/userService"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"CreateUser": kitex.NewMethodInfo(
		createUserHandler,
		newCreateUserArgs,
		newCreateUserResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CreateUsers": kitex.NewMethodInfo(
		createUsersHandler,
		newCreateUsersArgs,
		newCreateUsersResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"FindUserByID": kitex.NewMethodInfo(
		findUserByIDHandler,
		newFindUserByIDArgs,
		newFindUserByIDResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"FindUsersByIDs": kitex.NewMethodInfo(
		findUsersByIDsHandler,
		newFindUsersByIDsArgs,
		newFindUsersByIDsResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"FindUsersByName": kitex.NewMethodInfo(
		findUsersByNameHandler,
		newFindUsersByNameArgs,
		newFindUsersByNameResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"FindUsers": kitex.NewMethodInfo(
		findUsersHandler,
		newFindUsersArgs,
		newFindUsersResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"VerifyPassword": kitex.NewMethodInfo(
		verifyPasswordHandler,
		newVerifyPasswordArgs,
		newVerifyPasswordResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"DeleteUser": kitex.NewMethodInfo(
		deleteUserHandler,
		newDeleteUserArgs,
		newDeleteUserResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"DeleteUsers": kitex.NewMethodInfo(
		deleteUsersHandler,
		newDeleteUsersArgs,
		newDeleteUsersResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UpdateEmail": kitex.NewMethodInfo(
		updateEmailHandler,
		newUpdateEmailArgs,
		newUpdateEmailResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UpdateName": kitex.NewMethodInfo(
		updateNameHandler,
		newUpdateNameArgs,
		newUpdateNameResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UpdateUserName": kitex.NewMethodInfo(
		updateUserNameHandler,
		newUpdateUserNameArgs,
		newUpdateUserNameResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UpdatePhone": kitex.NewMethodInfo(
		updatePhoneHandler,
		newUpdatePhoneArgs,
		newUpdatePhoneResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ChangeAdminStatus": kitex.NewMethodInfo(
		changeAdminStatusHandler,
		newChangeAdminStatusArgs,
		newChangeAdminStatusResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	userServiceInfo                = NewServiceInfo()
	userServiceInfoForClient       = NewServiceInfoForClient()
	userServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return userServiceInfo
}

// for stream client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return userServiceInfoForStreamClient
}

// for client
func serviceInfoForClient() *kitex.ServiceInfo {
	return userServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "User"
	handlerType := (*userService.User)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "userService",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.15.1",
		Extra:           extra,
	}
	return svcInfo
}

func createUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(userService.CreateUserRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(userService.User).CreateUser(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CreateUserArgs:
		success, err := handler.(userService.User).CreateUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateUserResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCreateUserArgs() interface{} {
	return &CreateUserArgs{}
}

func newCreateUserResult() interface{} {
	return &CreateUserResult{}
}

type CreateUserArgs struct {
	Req *userService.CreateUserRequest
}

func (p *CreateUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreateUserArgs) Unmarshal(in []byte) error {
	msg := new(userService.CreateUserRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateUserArgs_Req_DEFAULT *userService.CreateUserRequest

func (p *CreateUserArgs) GetReq() *userService.CreateUserRequest {
	if !p.IsSetReq() {
		return CreateUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateUserResult struct {
	Success *userService.CreateUserResponse
}

var CreateUserResult_Success_DEFAULT *userService.CreateUserResponse

func (p *CreateUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreateUserResult) Unmarshal(in []byte) error {
	msg := new(userService.CreateUserResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateUserResult) GetSuccess() *userService.CreateUserResponse {
	if !p.IsSetSuccess() {
		return CreateUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*userService.CreateUserResponse)
}

func (p *CreateUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateUserResult) GetResult() interface{} {
	return p.Success
}

func createUsersHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(userService.CreateUsersRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(userService.User).CreateUsers(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CreateUsersArgs:
		success, err := handler.(userService.User).CreateUsers(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateUsersResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCreateUsersArgs() interface{} {
	return &CreateUsersArgs{}
}

func newCreateUsersResult() interface{} {
	return &CreateUsersResult{}
}

type CreateUsersArgs struct {
	Req *userService.CreateUsersRequest
}

func (p *CreateUsersArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreateUsersArgs) Unmarshal(in []byte) error {
	msg := new(userService.CreateUsersRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateUsersArgs_Req_DEFAULT *userService.CreateUsersRequest

func (p *CreateUsersArgs) GetReq() *userService.CreateUsersRequest {
	if !p.IsSetReq() {
		return CreateUsersArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateUsersArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateUsersArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateUsersResult struct {
	Success *userService.CreateUsersResponse
}

var CreateUsersResult_Success_DEFAULT *userService.CreateUsersResponse

func (p *CreateUsersResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreateUsersResult) Unmarshal(in []byte) error {
	msg := new(userService.CreateUsersResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateUsersResult) GetSuccess() *userService.CreateUsersResponse {
	if !p.IsSetSuccess() {
		return CreateUsersResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateUsersResult) SetSuccess(x interface{}) {
	p.Success = x.(*userService.CreateUsersResponse)
}

func (p *CreateUsersResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateUsersResult) GetResult() interface{} {
	return p.Success
}

func findUserByIDHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(userService.FindUserByIDRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(userService.User).FindUserByID(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *FindUserByIDArgs:
		success, err := handler.(userService.User).FindUserByID(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*FindUserByIDResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newFindUserByIDArgs() interface{} {
	return &FindUserByIDArgs{}
}

func newFindUserByIDResult() interface{} {
	return &FindUserByIDResult{}
}

type FindUserByIDArgs struct {
	Req *userService.FindUserByIDRequest
}

func (p *FindUserByIDArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *FindUserByIDArgs) Unmarshal(in []byte) error {
	msg := new(userService.FindUserByIDRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var FindUserByIDArgs_Req_DEFAULT *userService.FindUserByIDRequest

func (p *FindUserByIDArgs) GetReq() *userService.FindUserByIDRequest {
	if !p.IsSetReq() {
		return FindUserByIDArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *FindUserByIDArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *FindUserByIDArgs) GetFirstArgument() interface{} {
	return p.Req
}

type FindUserByIDResult struct {
	Success *userService.FindUserByIDResponse
}

var FindUserByIDResult_Success_DEFAULT *userService.FindUserByIDResponse

func (p *FindUserByIDResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *FindUserByIDResult) Unmarshal(in []byte) error {
	msg := new(userService.FindUserByIDResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *FindUserByIDResult) GetSuccess() *userService.FindUserByIDResponse {
	if !p.IsSetSuccess() {
		return FindUserByIDResult_Success_DEFAULT
	}
	return p.Success
}

func (p *FindUserByIDResult) SetSuccess(x interface{}) {
	p.Success = x.(*userService.FindUserByIDResponse)
}

func (p *FindUserByIDResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *FindUserByIDResult) GetResult() interface{} {
	return p.Success
}

func findUsersByIDsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(userService.FindUsersByIDsRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(userService.User).FindUsersByIDs(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *FindUsersByIDsArgs:
		success, err := handler.(userService.User).FindUsersByIDs(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*FindUsersByIDsResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newFindUsersByIDsArgs() interface{} {
	return &FindUsersByIDsArgs{}
}

func newFindUsersByIDsResult() interface{} {
	return &FindUsersByIDsResult{}
}

type FindUsersByIDsArgs struct {
	Req *userService.FindUsersByIDsRequest
}

func (p *FindUsersByIDsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *FindUsersByIDsArgs) Unmarshal(in []byte) error {
	msg := new(userService.FindUsersByIDsRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var FindUsersByIDsArgs_Req_DEFAULT *userService.FindUsersByIDsRequest

func (p *FindUsersByIDsArgs) GetReq() *userService.FindUsersByIDsRequest {
	if !p.IsSetReq() {
		return FindUsersByIDsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *FindUsersByIDsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *FindUsersByIDsArgs) GetFirstArgument() interface{} {
	return p.Req
}

type FindUsersByIDsResult struct {
	Success *userService.FindUsersByIDsResponse
}

var FindUsersByIDsResult_Success_DEFAULT *userService.FindUsersByIDsResponse

func (p *FindUsersByIDsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *FindUsersByIDsResult) Unmarshal(in []byte) error {
	msg := new(userService.FindUsersByIDsResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *FindUsersByIDsResult) GetSuccess() *userService.FindUsersByIDsResponse {
	if !p.IsSetSuccess() {
		return FindUsersByIDsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *FindUsersByIDsResult) SetSuccess(x interface{}) {
	p.Success = x.(*userService.FindUsersByIDsResponse)
}

func (p *FindUsersByIDsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *FindUsersByIDsResult) GetResult() interface{} {
	return p.Success
}

func findUsersByNameHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(userService.FindUsersByNameRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(userService.User).FindUsersByName(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *FindUsersByNameArgs:
		success, err := handler.(userService.User).FindUsersByName(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*FindUsersByNameResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newFindUsersByNameArgs() interface{} {
	return &FindUsersByNameArgs{}
}

func newFindUsersByNameResult() interface{} {
	return &FindUsersByNameResult{}
}

type FindUsersByNameArgs struct {
	Req *userService.FindUsersByNameRequest
}

func (p *FindUsersByNameArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *FindUsersByNameArgs) Unmarshal(in []byte) error {
	msg := new(userService.FindUsersByNameRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var FindUsersByNameArgs_Req_DEFAULT *userService.FindUsersByNameRequest

func (p *FindUsersByNameArgs) GetReq() *userService.FindUsersByNameRequest {
	if !p.IsSetReq() {
		return FindUsersByNameArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *FindUsersByNameArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *FindUsersByNameArgs) GetFirstArgument() interface{} {
	return p.Req
}

type FindUsersByNameResult struct {
	Success *userService.FindUsersByNameResponse
}

var FindUsersByNameResult_Success_DEFAULT *userService.FindUsersByNameResponse

func (p *FindUsersByNameResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *FindUsersByNameResult) Unmarshal(in []byte) error {
	msg := new(userService.FindUsersByNameResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *FindUsersByNameResult) GetSuccess() *userService.FindUsersByNameResponse {
	if !p.IsSetSuccess() {
		return FindUsersByNameResult_Success_DEFAULT
	}
	return p.Success
}

func (p *FindUsersByNameResult) SetSuccess(x interface{}) {
	p.Success = x.(*userService.FindUsersByNameResponse)
}

func (p *FindUsersByNameResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *FindUsersByNameResult) GetResult() interface{} {
	return p.Success
}

func findUsersHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(userService.FindUsersRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(userService.User).FindUsers(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *FindUsersArgs:
		success, err := handler.(userService.User).FindUsers(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*FindUsersResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newFindUsersArgs() interface{} {
	return &FindUsersArgs{}
}

func newFindUsersResult() interface{} {
	return &FindUsersResult{}
}

type FindUsersArgs struct {
	Req *userService.FindUsersRequest
}

func (p *FindUsersArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *FindUsersArgs) Unmarshal(in []byte) error {
	msg := new(userService.FindUsersRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var FindUsersArgs_Req_DEFAULT *userService.FindUsersRequest

func (p *FindUsersArgs) GetReq() *userService.FindUsersRequest {
	if !p.IsSetReq() {
		return FindUsersArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *FindUsersArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *FindUsersArgs) GetFirstArgument() interface{} {
	return p.Req
}

type FindUsersResult struct {
	Success *userService.FindUsersResponse
}

var FindUsersResult_Success_DEFAULT *userService.FindUsersResponse

func (p *FindUsersResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *FindUsersResult) Unmarshal(in []byte) error {
	msg := new(userService.FindUsersResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *FindUsersResult) GetSuccess() *userService.FindUsersResponse {
	if !p.IsSetSuccess() {
		return FindUsersResult_Success_DEFAULT
	}
	return p.Success
}

func (p *FindUsersResult) SetSuccess(x interface{}) {
	p.Success = x.(*userService.FindUsersResponse)
}

func (p *FindUsersResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *FindUsersResult) GetResult() interface{} {
	return p.Success
}

func verifyPasswordHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(userService.VerifyPasswordRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(userService.User).VerifyPassword(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *VerifyPasswordArgs:
		success, err := handler.(userService.User).VerifyPassword(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*VerifyPasswordResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newVerifyPasswordArgs() interface{} {
	return &VerifyPasswordArgs{}
}

func newVerifyPasswordResult() interface{} {
	return &VerifyPasswordResult{}
}

type VerifyPasswordArgs struct {
	Req *userService.VerifyPasswordRequest
}

func (p *VerifyPasswordArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *VerifyPasswordArgs) Unmarshal(in []byte) error {
	msg := new(userService.VerifyPasswordRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var VerifyPasswordArgs_Req_DEFAULT *userService.VerifyPasswordRequest

func (p *VerifyPasswordArgs) GetReq() *userService.VerifyPasswordRequest {
	if !p.IsSetReq() {
		return VerifyPasswordArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *VerifyPasswordArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *VerifyPasswordArgs) GetFirstArgument() interface{} {
	return p.Req
}

type VerifyPasswordResult struct {
	Success *userService.VerifyPasswordResponse
}

var VerifyPasswordResult_Success_DEFAULT *userService.VerifyPasswordResponse

func (p *VerifyPasswordResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *VerifyPasswordResult) Unmarshal(in []byte) error {
	msg := new(userService.VerifyPasswordResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *VerifyPasswordResult) GetSuccess() *userService.VerifyPasswordResponse {
	if !p.IsSetSuccess() {
		return VerifyPasswordResult_Success_DEFAULT
	}
	return p.Success
}

func (p *VerifyPasswordResult) SetSuccess(x interface{}) {
	p.Success = x.(*userService.VerifyPasswordResponse)
}

func (p *VerifyPasswordResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *VerifyPasswordResult) GetResult() interface{} {
	return p.Success
}

func deleteUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(userService.DeleteUserRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(userService.User).DeleteUser(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *DeleteUserArgs:
		success, err := handler.(userService.User).DeleteUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteUserResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newDeleteUserArgs() interface{} {
	return &DeleteUserArgs{}
}

func newDeleteUserResult() interface{} {
	return &DeleteUserResult{}
}

type DeleteUserArgs struct {
	Req *userService.DeleteUserRequest
}

func (p *DeleteUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteUserArgs) Unmarshal(in []byte) error {
	msg := new(userService.DeleteUserRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteUserArgs_Req_DEFAULT *userService.DeleteUserRequest

func (p *DeleteUserArgs) GetReq() *userService.DeleteUserRequest {
	if !p.IsSetReq() {
		return DeleteUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteUserResult struct {
	Success *userService.DeleteUserResponse
}

var DeleteUserResult_Success_DEFAULT *userService.DeleteUserResponse

func (p *DeleteUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteUserResult) Unmarshal(in []byte) error {
	msg := new(userService.DeleteUserResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteUserResult) GetSuccess() *userService.DeleteUserResponse {
	if !p.IsSetSuccess() {
		return DeleteUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*userService.DeleteUserResponse)
}

func (p *DeleteUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteUserResult) GetResult() interface{} {
	return p.Success
}

func deleteUsersHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(userService.DeleteUsersRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(userService.User).DeleteUsers(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *DeleteUsersArgs:
		success, err := handler.(userService.User).DeleteUsers(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteUsersResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newDeleteUsersArgs() interface{} {
	return &DeleteUsersArgs{}
}

func newDeleteUsersResult() interface{} {
	return &DeleteUsersResult{}
}

type DeleteUsersArgs struct {
	Req *userService.DeleteUsersRequest
}

func (p *DeleteUsersArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteUsersArgs) Unmarshal(in []byte) error {
	msg := new(userService.DeleteUsersRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteUsersArgs_Req_DEFAULT *userService.DeleteUsersRequest

func (p *DeleteUsersArgs) GetReq() *userService.DeleteUsersRequest {
	if !p.IsSetReq() {
		return DeleteUsersArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteUsersArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteUsersArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteUsersResult struct {
	Success *userService.DeleteUsersResponse
}

var DeleteUsersResult_Success_DEFAULT *userService.DeleteUsersResponse

func (p *DeleteUsersResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteUsersResult) Unmarshal(in []byte) error {
	msg := new(userService.DeleteUsersResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteUsersResult) GetSuccess() *userService.DeleteUsersResponse {
	if !p.IsSetSuccess() {
		return DeleteUsersResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteUsersResult) SetSuccess(x interface{}) {
	p.Success = x.(*userService.DeleteUsersResponse)
}

func (p *DeleteUsersResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteUsersResult) GetResult() interface{} {
	return p.Success
}

func updateEmailHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(userService.UpdateUserEmailRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(userService.User).UpdateEmail(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UpdateEmailArgs:
		success, err := handler.(userService.User).UpdateEmail(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdateEmailResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUpdateEmailArgs() interface{} {
	return &UpdateEmailArgs{}
}

func newUpdateEmailResult() interface{} {
	return &UpdateEmailResult{}
}

type UpdateEmailArgs struct {
	Req *userService.UpdateUserEmailRequest
}

func (p *UpdateEmailArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UpdateEmailArgs) Unmarshal(in []byte) error {
	msg := new(userService.UpdateUserEmailRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdateEmailArgs_Req_DEFAULT *userService.UpdateUserEmailRequest

func (p *UpdateEmailArgs) GetReq() *userService.UpdateUserEmailRequest {
	if !p.IsSetReq() {
		return UpdateEmailArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdateEmailArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdateEmailArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdateEmailResult struct {
	Success *userService.UpdateUserEmailResponse
}

var UpdateEmailResult_Success_DEFAULT *userService.UpdateUserEmailResponse

func (p *UpdateEmailResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UpdateEmailResult) Unmarshal(in []byte) error {
	msg := new(userService.UpdateUserEmailResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdateEmailResult) GetSuccess() *userService.UpdateUserEmailResponse {
	if !p.IsSetSuccess() {
		return UpdateEmailResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdateEmailResult) SetSuccess(x interface{}) {
	p.Success = x.(*userService.UpdateUserEmailResponse)
}

func (p *UpdateEmailResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateEmailResult) GetResult() interface{} {
	return p.Success
}

func updateNameHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(userService.UpdateNameRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(userService.User).UpdateName(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UpdateNameArgs:
		success, err := handler.(userService.User).UpdateName(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdateNameResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUpdateNameArgs() interface{} {
	return &UpdateNameArgs{}
}

func newUpdateNameResult() interface{} {
	return &UpdateNameResult{}
}

type UpdateNameArgs struct {
	Req *userService.UpdateNameRequest
}

func (p *UpdateNameArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UpdateNameArgs) Unmarshal(in []byte) error {
	msg := new(userService.UpdateNameRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdateNameArgs_Req_DEFAULT *userService.UpdateNameRequest

func (p *UpdateNameArgs) GetReq() *userService.UpdateNameRequest {
	if !p.IsSetReq() {
		return UpdateNameArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdateNameArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdateNameArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdateNameResult struct {
	Success *userService.UpdateNameResponse
}

var UpdateNameResult_Success_DEFAULT *userService.UpdateNameResponse

func (p *UpdateNameResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UpdateNameResult) Unmarshal(in []byte) error {
	msg := new(userService.UpdateNameResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdateNameResult) GetSuccess() *userService.UpdateNameResponse {
	if !p.IsSetSuccess() {
		return UpdateNameResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdateNameResult) SetSuccess(x interface{}) {
	p.Success = x.(*userService.UpdateNameResponse)
}

func (p *UpdateNameResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateNameResult) GetResult() interface{} {
	return p.Success
}

func updateUserNameHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(userService.UpdateUserNameRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(userService.User).UpdateUserName(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UpdateUserNameArgs:
		success, err := handler.(userService.User).UpdateUserName(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdateUserNameResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUpdateUserNameArgs() interface{} {
	return &UpdateUserNameArgs{}
}

func newUpdateUserNameResult() interface{} {
	return &UpdateUserNameResult{}
}

type UpdateUserNameArgs struct {
	Req *userService.UpdateUserNameRequest
}

func (p *UpdateUserNameArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UpdateUserNameArgs) Unmarshal(in []byte) error {
	msg := new(userService.UpdateUserNameRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdateUserNameArgs_Req_DEFAULT *userService.UpdateUserNameRequest

func (p *UpdateUserNameArgs) GetReq() *userService.UpdateUserNameRequest {
	if !p.IsSetReq() {
		return UpdateUserNameArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdateUserNameArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdateUserNameArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdateUserNameResult struct {
	Success *userService.UpdateUserNameResponse
}

var UpdateUserNameResult_Success_DEFAULT *userService.UpdateUserNameResponse

func (p *UpdateUserNameResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UpdateUserNameResult) Unmarshal(in []byte) error {
	msg := new(userService.UpdateUserNameResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdateUserNameResult) GetSuccess() *userService.UpdateUserNameResponse {
	if !p.IsSetSuccess() {
		return UpdateUserNameResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdateUserNameResult) SetSuccess(x interface{}) {
	p.Success = x.(*userService.UpdateUserNameResponse)
}

func (p *UpdateUserNameResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateUserNameResult) GetResult() interface{} {
	return p.Success
}

func updatePhoneHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(userService.UpdateUserPhoneRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(userService.User).UpdatePhone(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UpdatePhoneArgs:
		success, err := handler.(userService.User).UpdatePhone(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdatePhoneResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUpdatePhoneArgs() interface{} {
	return &UpdatePhoneArgs{}
}

func newUpdatePhoneResult() interface{} {
	return &UpdatePhoneResult{}
}

type UpdatePhoneArgs struct {
	Req *userService.UpdateUserPhoneRequest
}

func (p *UpdatePhoneArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UpdatePhoneArgs) Unmarshal(in []byte) error {
	msg := new(userService.UpdateUserPhoneRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdatePhoneArgs_Req_DEFAULT *userService.UpdateUserPhoneRequest

func (p *UpdatePhoneArgs) GetReq() *userService.UpdateUserPhoneRequest {
	if !p.IsSetReq() {
		return UpdatePhoneArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdatePhoneArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdatePhoneArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdatePhoneResult struct {
	Success *userService.UpdateUserPhoneResponse
}

var UpdatePhoneResult_Success_DEFAULT *userService.UpdateUserPhoneResponse

func (p *UpdatePhoneResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UpdatePhoneResult) Unmarshal(in []byte) error {
	msg := new(userService.UpdateUserPhoneResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdatePhoneResult) GetSuccess() *userService.UpdateUserPhoneResponse {
	if !p.IsSetSuccess() {
		return UpdatePhoneResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdatePhoneResult) SetSuccess(x interface{}) {
	p.Success = x.(*userService.UpdateUserPhoneResponse)
}

func (p *UpdatePhoneResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdatePhoneResult) GetResult() interface{} {
	return p.Success
}

func changeAdminStatusHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(userService.ChangeAdminStatusRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(userService.User).ChangeAdminStatus(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ChangeAdminStatusArgs:
		success, err := handler.(userService.User).ChangeAdminStatus(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ChangeAdminStatusResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newChangeAdminStatusArgs() interface{} {
	return &ChangeAdminStatusArgs{}
}

func newChangeAdminStatusResult() interface{} {
	return &ChangeAdminStatusResult{}
}

type ChangeAdminStatusArgs struct {
	Req *userService.ChangeAdminStatusRequest
}

func (p *ChangeAdminStatusArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ChangeAdminStatusArgs) Unmarshal(in []byte) error {
	msg := new(userService.ChangeAdminStatusRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ChangeAdminStatusArgs_Req_DEFAULT *userService.ChangeAdminStatusRequest

func (p *ChangeAdminStatusArgs) GetReq() *userService.ChangeAdminStatusRequest {
	if !p.IsSetReq() {
		return ChangeAdminStatusArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ChangeAdminStatusArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ChangeAdminStatusArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ChangeAdminStatusResult struct {
	Success *userService.ChangeAdminStatusResponse
}

var ChangeAdminStatusResult_Success_DEFAULT *userService.ChangeAdminStatusResponse

func (p *ChangeAdminStatusResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ChangeAdminStatusResult) Unmarshal(in []byte) error {
	msg := new(userService.ChangeAdminStatusResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ChangeAdminStatusResult) GetSuccess() *userService.ChangeAdminStatusResponse {
	if !p.IsSetSuccess() {
		return ChangeAdminStatusResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ChangeAdminStatusResult) SetSuccess(x interface{}) {
	p.Success = x.(*userService.ChangeAdminStatusResponse)
}

func (p *ChangeAdminStatusResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChangeAdminStatusResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) CreateUser(ctx context.Context, Req *userService.CreateUserRequest) (r *userService.CreateUserResponse, err error) {
	var _args CreateUserArgs
	_args.Req = Req
	var _result CreateUserResult
	if err = p.c.Call(ctx, "CreateUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateUsers(ctx context.Context, Req *userService.CreateUsersRequest) (r *userService.CreateUsersResponse, err error) {
	var _args CreateUsersArgs
	_args.Req = Req
	var _result CreateUsersResult
	if err = p.c.Call(ctx, "CreateUsers", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) FindUserByID(ctx context.Context, Req *userService.FindUserByIDRequest) (r *userService.FindUserByIDResponse, err error) {
	var _args FindUserByIDArgs
	_args.Req = Req
	var _result FindUserByIDResult
	if err = p.c.Call(ctx, "FindUserByID", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) FindUsersByIDs(ctx context.Context, Req *userService.FindUsersByIDsRequest) (r *userService.FindUsersByIDsResponse, err error) {
	var _args FindUsersByIDsArgs
	_args.Req = Req
	var _result FindUsersByIDsResult
	if err = p.c.Call(ctx, "FindUsersByIDs", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) FindUsersByName(ctx context.Context, Req *userService.FindUsersByNameRequest) (r *userService.FindUsersByNameResponse, err error) {
	var _args FindUsersByNameArgs
	_args.Req = Req
	var _result FindUsersByNameResult
	if err = p.c.Call(ctx, "FindUsersByName", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) FindUsers(ctx context.Context, Req *userService.FindUsersRequest) (r *userService.FindUsersResponse, err error) {
	var _args FindUsersArgs
	_args.Req = Req
	var _result FindUsersResult
	if err = p.c.Call(ctx, "FindUsers", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) VerifyPassword(ctx context.Context, Req *userService.VerifyPasswordRequest) (r *userService.VerifyPasswordResponse, err error) {
	var _args VerifyPasswordArgs
	_args.Req = Req
	var _result VerifyPasswordResult
	if err = p.c.Call(ctx, "VerifyPassword", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteUser(ctx context.Context, Req *userService.DeleteUserRequest) (r *userService.DeleteUserResponse, err error) {
	var _args DeleteUserArgs
	_args.Req = Req
	var _result DeleteUserResult
	if err = p.c.Call(ctx, "DeleteUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteUsers(ctx context.Context, Req *userService.DeleteUsersRequest) (r *userService.DeleteUsersResponse, err error) {
	var _args DeleteUsersArgs
	_args.Req = Req
	var _result DeleteUsersResult
	if err = p.c.Call(ctx, "DeleteUsers", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdateEmail(ctx context.Context, Req *userService.UpdateUserEmailRequest) (r *userService.UpdateUserEmailResponse, err error) {
	var _args UpdateEmailArgs
	_args.Req = Req
	var _result UpdateEmailResult
	if err = p.c.Call(ctx, "UpdateEmail", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdateName(ctx context.Context, Req *userService.UpdateNameRequest) (r *userService.UpdateNameResponse, err error) {
	var _args UpdateNameArgs
	_args.Req = Req
	var _result UpdateNameResult
	if err = p.c.Call(ctx, "UpdateName", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdateUserName(ctx context.Context, Req *userService.UpdateUserNameRequest) (r *userService.UpdateUserNameResponse, err error) {
	var _args UpdateUserNameArgs
	_args.Req = Req
	var _result UpdateUserNameResult
	if err = p.c.Call(ctx, "UpdateUserName", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdatePhone(ctx context.Context, Req *userService.UpdateUserPhoneRequest) (r *userService.UpdateUserPhoneResponse, err error) {
	var _args UpdatePhoneArgs
	_args.Req = Req
	var _result UpdatePhoneResult
	if err = p.c.Call(ctx, "UpdatePhone", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ChangeAdminStatus(ctx context.Context, Req *userService.ChangeAdminStatusRequest) (r *userService.ChangeAdminStatusResponse, err error) {
	var _args ChangeAdminStatusArgs
	_args.Req = Req
	var _result ChangeAdminStatusResult
	if err = p.c.Call(ctx, "ChangeAdminStatus", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
